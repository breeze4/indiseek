{
  "type": "excalidraw",
  "version": 2,
  "source": "https://excalidraw.com",
  "elements": [
    {
      "id": "title",
      "type": "text",
      "x": 60,
      "y": 20,
      "width": 500,
      "height": 37.8,
      "text": "LanceDB Deep Dive",
      "fontSize": 28,
      "fontFamily": 2,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#e67700",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "LanceDB Deep Dive"
    },
    {
      "id": "subtitle",
      "type": "text",
      "x": 60,
      "y": 56,
      "width": 800,
      "height": 18.9,
      "text": "How indiseek uses LanceDB as a vector database for semantic code search, explained from first principles",
      "fontSize": 14,
      "fontFamily": 2,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#868e96",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "How indiseek uses LanceDB as a vector database for semantic code search, explained from first principles"
    },

    {
      "id": "sec1-label",
      "type": "text",
      "x": 60,
      "y": 88,
      "width": 200,
      "height": 14.85,
      "text": "FUNDAMENTALS",
      "fontSize": 11,
      "fontFamily": 2,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#e67700",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "FUNDAMENTALS"
    },

    {
      "id": "what-hdr",
      "type": "rectangle",
      "x": 60,
      "y": 110,
      "width": 420,
      "height": 30,
      "strokeColor": "#e67700",
      "backgroundColor": "#e67700",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "what-title",
      "type": "text",
      "x": 70,
      "y": 116,
      "width": 300,
      "height": 20.25,
      "text": "What is LanceDB?",
      "fontSize": 15,
      "fontFamily": 2,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#ffffff",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "What is LanceDB?"
    },
    {
      "id": "what-body",
      "type": "rectangle",
      "x": 60,
      "y": 140,
      "width": 420,
      "height": 260,
      "strokeColor": "#dee2e6",
      "backgroundColor": "#f8f9fa",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "what-text",
      "type": "text",
      "x": 70,
      "y": 148,
      "width": 400,
      "height": 244,
      "text": "An EMBEDDED vector database. Key properties:\n\n1. NO SERVER PROCESS\n   - Just a Python library (pip install lancedb)\n   - Reads/writes files directly on disk\n   - Like SQLite, but for vectors\n\n2. STORES VECTORS + METADATA TOGETHER\n   - Each row = one embedding vector + columns\n   - Built on Apache Arrow columnar format\n   - On disk as .lance files (Arrow IPC)\n\n3. ENABLES SIMILARITY SEARCH\n   - \"Find the 10 vectors most similar to X\"\n   - Uses cosine distance (or L2, dot product)\n   - Returns results ranked by closeness\n\n4. WHY NOT JUST USE SQLite?\n   - SQLite can't do nearest-neighbor search\n   - Comparing 768-dim vectors needs special indexing\n   - LanceDB uses IVF-PQ (inverted file + quantization)",
      "fontSize": 11,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#1e1e1e",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "An EMBEDDED vector database. Key properties:\n\n1. NO SERVER PROCESS\n   - Just a Python library (pip install lancedb)\n   - Reads/writes files directly on disk\n   - Like SQLite, but for vectors\n\n2. STORES VECTORS + METADATA TOGETHER\n   - Each row = one embedding vector + columns\n   - Built on Apache Arrow columnar format\n   - On disk as .lance files (Arrow IPC)\n\n3. ENABLES SIMILARITY SEARCH\n   - \"Find the 10 vectors most similar to X\"\n   - Uses cosine distance (or L2, dot product)\n   - Returns results ranked by closeness\n\n4. WHY NOT JUST USE SQLite?\n   - SQLite can't do nearest-neighbor search\n   - Comparing 768-dim vectors needs special indexing\n   - LanceDB uses IVF-PQ (inverted file + quantization)"
    },

    {
      "id": "vec-hdr",
      "type": "rectangle",
      "x": 500,
      "y": 110,
      "width": 420,
      "height": 30,
      "strokeColor": "#e67700",
      "backgroundColor": "#e67700",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "vec-title",
      "type": "text",
      "x": 510,
      "y": 116,
      "width": 300,
      "height": 20.25,
      "text": "What is a Vector Embedding?",
      "fontSize": 15,
      "fontFamily": 2,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#ffffff",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "What is a Vector Embedding?"
    },
    {
      "id": "vec-body",
      "type": "rectangle",
      "x": 500,
      "y": 140,
      "width": 420,
      "height": 260,
      "strokeColor": "#dee2e6",
      "backgroundColor": "#f8f9fa",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "vec-text",
      "type": "text",
      "x": 510,
      "y": 148,
      "width": 400,
      "height": 244,
      "text": "A FIXED-SIZE ARRAY OF FLOATS that captures meaning.\n\nAn LLM (Gemini) reads source code and outputs a\nlist of 768 numbers. Each number is a \"meaning axis\".\n\nExample (simplified to 4 dimensions):\n\n  createServer() -> [0.92, 0.11, 0.87, 0.03]\n  startServer()  -> [0.89, 0.14, 0.84, 0.06]\n  parseCss()     -> [0.12, 0.91, 0.08, 0.88]\n\nNotice: createServer and startServer have SIMILAR\nnumbers because they do similar things. parseCss\nis totally different code, so different numbers.\n\nThe KEY INSIGHT:\n  Similar code  -->  similar vectors\n  Similar vectors --> close in 768-d space\n  Close in space  --> small cosine distance\n\nSo \"find code related to HMR\" becomes:\n  1. Embed the query into a vector\n  2. Find stored vectors closest to it",
      "fontSize": 11,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#1e1e1e",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "A FIXED-SIZE ARRAY OF FLOATS that captures meaning.\n\nAn LLM (Gemini) reads source code and outputs a\nlist of 768 numbers. Each number is a \"meaning axis\".\n\nExample (simplified to 4 dimensions):\n\n  createServer() -> [0.92, 0.11, 0.87, 0.03]\n  startServer()  -> [0.89, 0.14, 0.84, 0.06]\n  parseCss()     -> [0.12, 0.91, 0.08, 0.88]\n\nNotice: createServer and startServer have SIMILAR\nnumbers because they do similar things. parseCss\nis totally different code, so different numbers.\n\nThe KEY INSIGHT:\n  Similar code  -->  similar vectors\n  Similar vectors --> close in 768-d space\n  Close in space  --> small cosine distance\n\nSo \"find code related to HMR\" becomes:\n  1. Embed the query into a vector\n  2. Find stored vectors closest to it"
    },

    {
      "id": "disk-hdr",
      "type": "rectangle",
      "x": 940,
      "y": 110,
      "width": 420,
      "height": 30,
      "strokeColor": "#e67700",
      "backgroundColor": "#e67700",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "disk-title",
      "type": "text",
      "x": 950,
      "y": 116,
      "width": 300,
      "height": 20.25,
      "text": "On-Disk File Layout",
      "fontSize": 15,
      "fontFamily": 2,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#ffffff",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "On-Disk File Layout"
    },
    {
      "id": "disk-body",
      "type": "rectangle",
      "x": 940,
      "y": 140,
      "width": 420,
      "height": 260,
      "strokeColor": "#dee2e6",
      "backgroundColor": "#f8f9fa",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "disk-text",
      "type": "text",
      "x": 950,
      "y": 148,
      "width": 400,
      "height": 244,
      "text": "data/lancedb/             <-- db_path (a directory)\n  chunks.lance/           <-- one dir per table\n    _versions/\n      1.manifest          <-- version 1 metadata\n      2.manifest          <-- version 2 (after add)\n    _latest.manifest      <-- points to current ver\n    data/\n      b8a3e0f1...0.lance  <-- actual data (Arrow IPC)\n      c4d2f7a9...0.lance  <-- more data fragments\n    _indices/             <-- ANN index (if created)\n      idx_uuid/\n        index.idx\n\nLance columnar format:\n  - Each .lance file is Arrow IPC (binary columnar)\n  - Vectors stored as FixedSizeList<float32, 768>\n  - Metadata stored as standard Arrow columns\n  - Append-only: add() creates new fragments\n  - Versions: each write creates a new manifest\n  - Old versions auto-cleaned after retention period\n\nConnection code:  lancedb.connect(\"data/lancedb\")\n  Creates dir if missing. No daemon needed.",
      "fontSize": 11,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#1e1e1e",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "data/lancedb/             <-- db_path (a directory)\n  chunks.lance/           <-- one dir per table\n    _versions/\n      1.manifest          <-- version 1 metadata\n      2.manifest          <-- version 2 (after add)\n    _latest.manifest      <-- points to current ver\n    data/\n      b8a3e0f1...0.lance  <-- actual data (Arrow IPC)\n      c4d2f7a9...0.lance  <-- more data fragments\n    _indices/             <-- ANN index (if created)\n      idx_uuid/\n        index.idx\n\nLance columnar format:\n  - Each .lance file is Arrow IPC (binary columnar)\n  - Vectors stored as FixedSizeList<float32, 768>\n  - Metadata stored as standard Arrow columns\n  - Append-only: add() creates new fragments\n  - Versions: each write creates a new manifest\n  - Old versions auto-cleaned after retention period\n\nConnection code:  lancedb.connect(\"data/lancedb\")\n  Creates dir if missing. No daemon needed."
    },

    {
      "id": "sec2-label",
      "type": "text",
      "x": 60,
      "y": 418,
      "width": 300,
      "height": 14.85,
      "text": "THIS PROJECT'S IMPLEMENTATION  (vector_store.py)",
      "fontSize": 11,
      "fontFamily": 2,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#1971c2",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "THIS PROJECT'S IMPLEMENTATION  (vector_store.py)"
    },

    {
      "id": "schema-hdr",
      "type": "rectangle",
      "x": 60,
      "y": 440,
      "width": 420,
      "height": 30,
      "strokeColor": "#1971c2",
      "backgroundColor": "#1971c2",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "schema-title",
      "type": "text",
      "x": 70,
      "y": 446,
      "width": 350,
      "height": 20.25,
      "text": "Table Schema (PyArrow definition)",
      "fontSize": 15,
      "fontFamily": 2,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#ffffff",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "Table Schema (PyArrow definition)"
    },
    {
      "id": "schema-body",
      "type": "rectangle",
      "x": 60,
      "y": 470,
      "width": 420,
      "height": 370,
      "strokeColor": "#dee2e6",
      "backgroundColor": "#f8f9fa",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "schema-text",
      "type": "text",
      "x": 70,
      "y": 478,
      "width": 400,
      "height": 355,
      "text": "Table name: \"chunks\"   (VectorStore.TABLE_NAME)\n\npa.schema([\n  pa.field(\"vector\",\n    pa.list_(pa.float32(), 768)),   # THE VECTOR\n  pa.field(\"chunk_id\",    pa.int64()),\n  pa.field(\"file_path\",   pa.utf8()),\n  pa.field(\"symbol_name\", pa.utf8()),\n  pa.field(\"chunk_type\",  pa.utf8()),\n  pa.field(\"content\",     pa.utf8()),\n])\n\nColumn details:\n\nvector       768 x float32 = 3,072 bytes per row\n             This is what LanceDB indexes & searches.\n             Generated by Gemini embedding API.\n\nchunk_id     Foreign key -> SQLite chunks.id\n             THE JOIN KEY to correlate results.\n\nfile_path    \"packages/vite/src/node/server/index.ts\"\nsymbol_name  \"createServer\"  (\"\" for module chunks)\nchunk_type   function|class|method|interface|type|...\ncontent      Full source text of the code chunk\n\nMetadata is DENORMALIZED from SQLite. This means\nLanceDB search results are self-contained -- no\nneed to JOIN back to SQLite during queries.",
      "fontSize": 11,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#1e1e1e",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "Table name: \"chunks\"   (VectorStore.TABLE_NAME)\n\npa.schema([\n  pa.field(\"vector\",\n    pa.list_(pa.float32(), 768)),   # THE VECTOR\n  pa.field(\"chunk_id\",    pa.int64()),\n  pa.field(\"file_path\",   pa.utf8()),\n  pa.field(\"symbol_name\", pa.utf8()),\n  pa.field(\"chunk_type\",  pa.utf8()),\n  pa.field(\"content\",     pa.utf8()),\n])\n\nColumn details:\n\nvector       768 x float32 = 3,072 bytes per row\n             This is what LanceDB indexes & searches.\n             Generated by Gemini embedding API.\n\nchunk_id     Foreign key -> SQLite chunks.id\n             THE JOIN KEY to correlate results.\n\nfile_path    \"packages/vite/src/node/server/index.ts\"\nsymbol_name  \"createServer\"  (\"\" for module chunks)\nchunk_type   function|class|method|interface|type|...\ncontent      Full source text of the code chunk\n\nMetadata is DENORMALIZED from SQLite. This means\nLanceDB search results are self-contained -- no\nneed to JOIN back to SQLite during queries."
    },

    {
      "id": "write-hdr",
      "type": "rectangle",
      "x": 500,
      "y": 440,
      "width": 420,
      "height": 30,
      "strokeColor": "#1971c2",
      "backgroundColor": "#1971c2",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "write-title",
      "type": "text",
      "x": 510,
      "y": 446,
      "width": 350,
      "height": 20.25,
      "text": "Write Path: Indexing Pipeline",
      "fontSize": 15,
      "fontFamily": 2,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#ffffff",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "Write Path: Indexing Pipeline"
    },
    {
      "id": "write-body",
      "type": "rectangle",
      "x": 500,
      "y": 470,
      "width": 420,
      "height": 370,
      "strokeColor": "#dee2e6",
      "backgroundColor": "#f8f9fa",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "write-text",
      "type": "text",
      "x": 510,
      "y": 478,
      "width": 400,
      "height": 355,
      "text": "scripts/index.py --embed  triggers this pipeline:\n\nSQLite chunks table (source of truth)\n  |\n  | SELECT id, file_path, symbol_name,\n  |        chunk_type, content FROM chunks\n  |                                    embedder.py\n  v\nAll chunks loaded into memory\n  |\n  | Filter out chunk_ids already in LanceDB\n  | (resume support: get_chunk_ids())\n  v\nBatches of 20 chunks\n  |\n  | For each batch:\n  |   texts = [chunk.content for chunk in batch]\n  |   vectors = GeminiProvider.embed(texts)\n  |                                    provider.py\n  |   API call: gemini-embedding-001\n  |   Input: raw source code strings\n  |   Output: list of 768-dim float32 vectors\n  v\nVectorStore.add_chunks(vectors, metadata)\n  |\n  | Builds list of dicts, one per chunk:\n  |   {\"vector\": [...768 floats...],\n  |    \"chunk_id\": 137,\n  |    \"file_path\": \"src/.../index.ts\",\n  |    \"symbol_name\": \"createServer\",\n  |    \"chunk_type\": \"function\",\n  |    \"content\": \"export function...\"}\n  v\ntable.add(rows)  -->  new .lance fragment on disk",
      "fontSize": 11,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#1e1e1e",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "scripts/index.py --embed  triggers this pipeline:\n\nSQLite chunks table (source of truth)\n  |\n  | SELECT id, file_path, symbol_name,\n  |        chunk_type, content FROM chunks\n  |                                    embedder.py\n  v\nAll chunks loaded into memory\n  |\n  | Filter out chunk_ids already in LanceDB\n  | (resume support: get_chunk_ids())\n  v\nBatches of 20 chunks\n  |\n  | For each batch:\n  |   texts = [chunk.content for chunk in batch]\n  |   vectors = GeminiProvider.embed(texts)\n  |                                    provider.py\n  |   API call: gemini-embedding-001\n  |   Input: raw source code strings\n  |   Output: list of 768-dim float32 vectors\n  v\nVectorStore.add_chunks(vectors, metadata)\n  |\n  | Builds list of dicts, one per chunk:\n  |   {\"vector\": [...768 floats...],\n  |    \"chunk_id\": 137,\n  |    \"file_path\": \"src/.../index.ts\",\n  |    \"symbol_name\": \"createServer\",\n  |    \"chunk_type\": \"function\",\n  |    \"content\": \"export function...\"}\n  v\ntable.add(rows)  -->  new .lance fragment on disk"
    },

    {
      "id": "read-hdr",
      "type": "rectangle",
      "x": 940,
      "y": 440,
      "width": 420,
      "height": 30,
      "strokeColor": "#1971c2",
      "backgroundColor": "#1971c2",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "read-title",
      "type": "text",
      "x": 950,
      "y": 446,
      "width": 350,
      "height": 20.25,
      "text": "Read Path: Search at Query Time",
      "fontSize": 15,
      "fontFamily": 2,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#ffffff",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "Read Path: Search at Query Time"
    },
    {
      "id": "read-body",
      "type": "rectangle",
      "x": 940,
      "y": 470,
      "width": 420,
      "height": 370,
      "strokeColor": "#dee2e6",
      "backgroundColor": "#f8f9fa",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "read-text",
      "type": "text",
      "x": 950,
      "y": 478,
      "width": 400,
      "height": 355,
      "text": "User query: \"How does HMR propagation work?\"\n                                   search_code.py\n  |\n  | Step 1: EMBED THE QUERY\n  |   Same model (gemini-embedding-001)\n  |   Same dims (768)\n  |   query_vec = provider.embed([query])[0]\n  |   --> [0.234, 0.567, ..., 0.890]  768 floats\n  v\n  |\n  | Step 2: SEARCH LANCEDB\n  |   table.search(query_vec)\n  |        .distance_type(\"cosine\")\n  |        .limit(10)\n  |        .to_list()\n  v\nLanceDB computes cosine distance between query_vec\nand EVERY stored vector (or uses ANN index).\nReturns top 10 closest matches:\n\n  [{\"chunk_id\": 873,\n    \"file_path\": \"src/node/server/hmr.ts\",\n    \"symbol_name\": \"handleHMRUpdate\",\n    \"content\": \"export function handleHMR...\",\n    \"_distance\": 0.12},      <-- cosine distance\n   {\"chunk_id\": 421, \"_distance\": 0.15},\n   ...]\n\nLower _distance = more semantically similar.\nResults pre-sorted by LanceDB (closest first).",
      "fontSize": 11,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#1e1e1e",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "User query: \"How does HMR propagation work?\"\n                                   search_code.py\n  |\n  | Step 1: EMBED THE QUERY\n  |   Same model (gemini-embedding-001)\n  |   Same dims (768)\n  |   query_vec = provider.embed([query])[0]\n  |   --> [0.234, 0.567, ..., 0.890]  768 floats\n  v\n  |\n  | Step 2: SEARCH LANCEDB\n  |   table.search(query_vec)\n  |        .distance_type(\"cosine\")\n  |        .limit(10)\n  |        .to_list()\n  v\nLanceDB computes cosine distance between query_vec\nand EVERY stored vector (or uses ANN index).\nReturns top 10 closest matches:\n\n  [{\"chunk_id\": 873,\n    \"file_path\": \"src/node/server/hmr.ts\",\n    \"symbol_name\": \"handleHMRUpdate\",\n    \"content\": \"export function handleHMR...\",\n    \"_distance\": 0.12},      <-- cosine distance\n   {\"chunk_id\": 421, \"_distance\": 0.15},\n   ...]\n\nLower _distance = more semantically similar.\nResults pre-sorted by LanceDB (closest first)."
    },

    {
      "id": "sec3-label",
      "type": "text",
      "x": 60,
      "y": 858,
      "width": 300,
      "height": 14.85,
      "text": "DEEP DIVES",
      "fontSize": 11,
      "fontFamily": 2,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#2b8a3e",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "DEEP DIVES"
    },

    {
      "id": "cos-hdr",
      "type": "rectangle",
      "x": 60,
      "y": 880,
      "width": 420,
      "height": 30,
      "strokeColor": "#2b8a3e",
      "backgroundColor": "#2b8a3e",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "cos-title",
      "type": "text",
      "x": 70,
      "y": 886,
      "width": 350,
      "height": 20.25,
      "text": "Cosine Distance Explained",
      "fontSize": 15,
      "fontFamily": 2,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#ffffff",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "Cosine Distance Explained"
    },
    {
      "id": "cos-body",
      "type": "rectangle",
      "x": 60,
      "y": 910,
      "width": 420,
      "height": 340,
      "strokeColor": "#dee2e6",
      "backgroundColor": "#f8f9fa",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "cos-text",
      "type": "text",
      "x": 70,
      "y": 918,
      "width": 400,
      "height": 325,
      "text": "Cosine SIMILARITY = how aligned two vectors are.\n  Formula: dot(A, B) / (|A| * |B|)\n  Range: -1 (opposite) to +1 (identical direction)\n\nCosine DISTANCE = 1 - similarity\n  Range: 0 (identical) to 2 (opposite)\n  This is what LanceDB returns as \"_distance\".\n\nWhy cosine and not Euclidean (L2) distance?\n  Cosine ignores MAGNITUDE, only cares about\n  DIRECTION. Two chunks with different lengths\n  but similar meaning get similar vectors.\n\nConcrete example (2D for visualization):\n\n  A = createServer  = [0.9, 0.1]   .\n  B = startServer   = [0.8, 0.2]  /\n  C = parseCss      = [0.1, 0.9]  |\n                                  |\n  cos_dist(A, B) = 0.005  (very close!)\n  cos_dist(A, C) = 0.810  (very far)\n\nIn 768 dimensions this works the same way,\njust impossible to visualize. The math is\nidentical -- dot product divided by magnitudes.\n\nLanceDB sorts results by _distance ascending.\nOur code inverts this: score = _distance\n(lower = better, confusing but consistent).",
      "fontSize": 11,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#1e1e1e",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "Cosine SIMILARITY = how aligned two vectors are.\n  Formula: dot(A, B) / (|A| * |B|)\n  Range: -1 (opposite) to +1 (identical direction)\n\nCosine DISTANCE = 1 - similarity\n  Range: 0 (identical) to 2 (opposite)\n  This is what LanceDB returns as \"_distance\".\n\nWhy cosine and not Euclidean (L2) distance?\n  Cosine ignores MAGNITUDE, only cares about\n  DIRECTION. Two chunks with different lengths\n  but similar meaning get similar vectors.\n\nConcrete example (2D for visualization):\n\n  A = createServer  = [0.9, 0.1]   .\n  B = startServer   = [0.8, 0.2]  /\n  C = parseCss      = [0.1, 0.9]  |\n                                  |\n  cos_dist(A, B) = 0.005  (very close!)\n  cos_dist(A, C) = 0.810  (very far)\n\nIn 768 dimensions this works the same way,\njust impossible to visualize. The math is\nidentical -- dot product divided by magnitudes.\n\nLanceDB sorts results by _distance ascending.\nOur code inverts this: score = _distance\n(lower = better, confusing but consistent)."
    },

    {
      "id": "robust-hdr",
      "type": "rectangle",
      "x": 500,
      "y": 880,
      "width": 420,
      "height": 30,
      "strokeColor": "#2b8a3e",
      "backgroundColor": "#2b8a3e",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "robust-title",
      "type": "text",
      "x": 510,
      "y": 886,
      "width": 350,
      "height": 20.25,
      "text": "Resume, Retry, and Lifecycle",
      "fontSize": 15,
      "fontFamily": 2,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#ffffff",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "Resume, Retry, and Lifecycle"
    },
    {
      "id": "robust-body",
      "type": "rectangle",
      "x": 500,
      "y": 910,
      "width": 420,
      "height": 340,
      "strokeColor": "#dee2e6",
      "backgroundColor": "#f8f9fa",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "robust-text",
      "type": "text",
      "x": 510,
      "y": 918,
      "width": 400,
      "height": 325,
      "text": "RESUME (embedder.py:38-49)\n  existing_ids = vector_store.get_chunk_ids()\n  Skip chunks where id is in existing_ids.\n  So: Ctrl+C during indexing? Just re-run.\n  Already-embedded chunks won't be re-embedded.\n\n  get_chunk_ids() reads entire table to Arrow,\n  extracts chunk_id column as Python set.\n\nRETRY (embedder.py:72-95)\n  Per-batch error handling:\n  1. Catch exception\n  2. Fail fast on auth errors (API_KEY_INVALID)\n  3. Sleep 2 seconds\n  4. Retry ONCE\n  5. If retry fails: skip batch, count error\n  6. 3 consecutive batch failures = abort\n\nTABLE LIFECYCLE\n  init_table():   Open if exists, create if not\n  reset_table():  Drop + recreate (clean re-embed)\n  add_chunks():   Append rows (no dedup built-in)\n  count():        Number of rows in table\n\nIMPORTANT: No deduplication.\n  If you add the same chunk_id twice, you get\n  duplicate rows. The resume logic prevents this\n  during normal indexing. reset_table() is the\n  escape hatch for a clean start.\n\nAuto-commit: table.add(rows) writes immediately.\n  No explicit commit/flush needed.",
      "fontSize": 11,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#1e1e1e",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "RESUME (embedder.py:38-49)\n  existing_ids = vector_store.get_chunk_ids()\n  Skip chunks where id is in existing_ids.\n  So: Ctrl+C during indexing? Just re-run.\n  Already-embedded chunks won't be re-embedded.\n\n  get_chunk_ids() reads entire table to Arrow,\n  extracts chunk_id column as Python set.\n\nRETRY (embedder.py:72-95)\n  Per-batch error handling:\n  1. Catch exception\n  2. Fail fast on auth errors (API_KEY_INVALID)\n  3. Sleep 2 seconds\n  4. Retry ONCE\n  5. If retry fails: skip batch, count error\n  6. 3 consecutive batch failures = abort\n\nTABLE LIFECYCLE\n  init_table():   Open if exists, create if not\n  reset_table():  Drop + recreate (clean re-embed)\n  add_chunks():   Append rows (no dedup built-in)\n  count():        Number of rows in table\n\nIMPORTANT: No deduplication.\n  If you add the same chunk_id twice, you get\n  duplicate rows. The resume logic prevents this\n  during normal indexing. reset_table() is the\n  escape hatch for a clean start.\n\nAuto-commit: table.add(rows) writes immediately.\n  No explicit commit/flush needed."
    },

    {
      "id": "hybrid-hdr",
      "type": "rectangle",
      "x": 940,
      "y": 880,
      "width": 420,
      "height": 30,
      "strokeColor": "#2b8a3e",
      "backgroundColor": "#2b8a3e",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "hybrid-title",
      "type": "text",
      "x": 950,
      "y": 886,
      "width": 350,
      "height": 20.25,
      "text": "Hybrid Search: LanceDB + Tantivy",
      "fontSize": 15,
      "fontFamily": 2,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#ffffff",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "Hybrid Search: LanceDB + Tantivy"
    },
    {
      "id": "hybrid-body",
      "type": "rectangle",
      "x": 940,
      "y": 910,
      "width": 420,
      "height": 340,
      "strokeColor": "#dee2e6",
      "backgroundColor": "#f8f9fa",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "hybrid-text",
      "type": "text",
      "x": 950,
      "y": 918,
      "width": 400,
      "height": 325,
      "text": "LanceDB handles SEMANTIC search (meaning).\nTantivy handles LEXICAL search (keywords).\nHybrid mode combines both via RRF.\n\n         query: \"HMR CSS propagation\"\n              /                  \\\n       LanceDB                  Tantivy\n    (cosine dist)              (BM25)\n    top 20 results          top 20 results\n              \\                  /\n         Reciprocal Rank Fusion (RRF)\n              merged top 10\n\nRRF formula (search_code.py:29-82):\n  For each result at rank r:\n    rrf_score = 1 / (k + r + 1)    where k=60\n\n  If chunk appears in BOTH result lists,\n  its scores are SUMMED. This promotes chunks\n  that are relevant by meaning AND keywords.\n\nWhy not just normalize and average scores?\n  Cosine distance (0-2) and BM25 score (0-inf)\n  are on completely different scales. RRF only\n  uses RANK POSITION, not raw scores, so it\n  works regardless of score scale.\n\nMatch types in results:\n  \"semantic\" = only found by LanceDB\n  \"lexical\"  = only found by Tantivy\n  \"hybrid\"   = found by BOTH (highest quality)",
      "fontSize": 11,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#1e1e1e",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "LanceDB handles SEMANTIC search (meaning).\nTantivy handles LEXICAL search (keywords).\nHybrid mode combines both via RRF.\n\n         query: \"HMR CSS propagation\"\n              /                  \\\n       LanceDB                  Tantivy\n    (cosine dist)              (BM25)\n    top 20 results          top 20 results\n              \\                  /\n         Reciprocal Rank Fusion (RRF)\n              merged top 10\n\nRRF formula (search_code.py:29-82):\n  For each result at rank r:\n    rrf_score = 1 / (k + r + 1)    where k=60\n\n  If chunk appears in BOTH result lists,\n  its scores are SUMMED. This promotes chunks\n  that are relevant by meaning AND keywords.\n\nWhy not just normalize and average scores?\n  Cosine distance (0-2) and BM25 score (0-inf)\n  are on completely different scales. RRF only\n  uses RANK POSITION, not raw scores, so it\n  works regardless of score scale.\n\nMatch types in results:\n  \"semantic\" = only found by LanceDB\n  \"lexical\"  = only found by Tantivy\n  \"hybrid\"   = found by BOTH (highest quality)"
    },

    {
      "id": "sec4-label",
      "type": "text",
      "x": 60,
      "y": 1268,
      "width": 300,
      "height": 14.85,
      "text": "CONCRETE EXAMPLE: ONE ROW END-TO-END",
      "fontSize": 11,
      "fontFamily": 2,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#495057",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "CONCRETE EXAMPLE: ONE ROW END-TO-END"
    },

    {
      "id": "ex-hdr",
      "type": "rectangle",
      "x": 60,
      "y": 1290,
      "width": 1300,
      "height": 30,
      "strokeColor": "#495057",
      "backgroundColor": "#495057",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "ex-title",
      "type": "text",
      "x": 70,
      "y": 1296,
      "width": 600,
      "height": 20.25,
      "text": "Tracing chunk_id=137 from source code to search result",
      "fontSize": 15,
      "fontFamily": 2,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#ffffff",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "Tracing chunk_id=137 from source code to search result"
    },
    {
      "id": "ex-body",
      "type": "rectangle",
      "x": 60,
      "y": 1320,
      "width": 1300,
      "height": 280,
      "strokeColor": "#dee2e6",
      "backgroundColor": "#f8f9fa",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "ex-text",
      "type": "text",
      "x": 70,
      "y": 1328,
      "width": 1280,
      "height": 265,
      "text": "Source file:  packages/vite/src/node/server/index.ts, lines 45-48\n              export function createServer(config: ServerConfig): Server {\n                const server = new HttpServer(config.port)\n                return server\n              }\n\nStep 1 (Tree-sitter):  Parser extracts this as a \"function\" chunk. Inserted into SQLite:\n              chunks row:  id=137, file_path=\"packages/vite/src/node/server/index.ts\", symbol_name=\"createServer\",\n                           chunk_type=\"function\", start_line=45, end_line=48, content=\"export function createServer...\"  \n\nStep 2 (Embedding):    Embedder reads chunk 137 from SQLite. Sends content to Gemini:\n              Input:  \"export function createServer(config: ServerConfig): Server { const server = new HttpServer(config.port)...\" \n              Output: [0.023, -0.041, 0.117, 0.089, -0.156, 0.034, ... 768 total floats ...]\n\nStep 3 (LanceDB):      VectorStore.add_chunks() inserts one row:\n              {vector: [0.023, -0.041, ...], chunk_id: 137, file_path: \"packages/vite/src/.../index.ts\",\n               symbol_name: \"createServer\", chunk_type: \"function\", content: \"export function createServer...\"}\n\nStep 4 (Query):        User asks \"How is the dev server created?\"  -->  embed query  -->  cosine search\n              LanceDB returns: {chunk_id: 137, _distance: 0.08, ...} because the query and chunk are semantically close.\n              This result includes all metadata (file_path, content, etc.) so no SQLite lookup needed.",
      "fontSize": 11,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#1e1e1e",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "Source file:  packages/vite/src/node/server/index.ts, lines 45-48\n              export function createServer(config: ServerConfig): Server {\n                const server = new HttpServer(config.port)\n                return server\n              }\n\nStep 1 (Tree-sitter):  Parser extracts this as a \"function\" chunk. Inserted into SQLite:\n              chunks row:  id=137, file_path=\"packages/vite/src/node/server/index.ts\", symbol_name=\"createServer\",\n                           chunk_type=\"function\", start_line=45, end_line=48, content=\"export function createServer...\"  \n\nStep 2 (Embedding):    Embedder reads chunk 137 from SQLite. Sends content to Gemini:\n              Input:  \"export function createServer(config: ServerConfig): Server { const server = new HttpServer(config.port)...\" \n              Output: [0.023, -0.041, 0.117, 0.089, -0.156, 0.034, ... 768 total floats ...]\n\nStep 3 (LanceDB):      VectorStore.add_chunks() inserts one row:\n              {vector: [0.023, -0.041, ...], chunk_id: 137, file_path: \"packages/vite/src/.../index.ts\",\n               symbol_name: \"createServer\", chunk_type: \"function\", content: \"export function createServer...\"}\n\nStep 4 (Query):        User asks \"How is the dev server created?\"  -->  embed query  -->  cosine search\n              LanceDB returns: {chunk_id: 137, _distance: 0.08, ...} because the query and chunk are semantically close.\n              This result includes all metadata (file_path, content, etc.) so no SQLite lookup needed."
    },

    {
      "id": "key-bg",
      "type": "rectangle",
      "x": 60,
      "y": 1620,
      "width": 1300,
      "height": 100,
      "strokeColor": "#e67700",
      "backgroundColor": "#fff3bf",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "key-text",
      "type": "text",
      "x": 75,
      "y": 1628,
      "width": 1270,
      "height": 84,
      "text": "KEY TAKEAWAYS\n\n1. LanceDB is the semantic brain. SQLite is the structured brain. Tantivy is the keyword brain. chunk_id connects them all.\n2. Embeddings are generated ONCE at index time by the Gemini API. At query time, only the query string needs embedding (one API call).\n3. Metadata is intentionally duplicated in LanceDB so that search results don't require a SQLite round-trip.\n4. LanceDB stores data as Apache Arrow files on disk -- no server, no docker, no config. Just a directory of .lance files.\n5. Cosine distance measures semantic similarity: lower distance = more similar meaning. Range 0 (identical) to 2 (opposite).",
      "fontSize": 11,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#1e1e1e",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "KEY TAKEAWAYS\n\n1. LanceDB is the semantic brain. SQLite is the structured brain. Tantivy is the keyword brain. chunk_id connects them all.\n2. Embeddings are generated ONCE at index time by the Gemini API. At query time, only the query string needs embedding (one API call).\n3. Metadata is intentionally duplicated in LanceDB so that search results don't require a SQLite round-trip.\n4. LanceDB stores data as Apache Arrow files on disk -- no server, no docker, no config. Just a directory of .lance files.\n5. Cosine distance measures semantic similarity: lower distance = more similar meaning. Range 0 (identical) to 2 (opposite)."
    },

    {
      "id": "files-bg",
      "type": "rectangle",
      "x": 60,
      "y": 1738,
      "width": 1300,
      "height": 55,
      "strokeColor": "#dee2e6",
      "backgroundColor": "#f1f3f5",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "roundness": { "type": 3 },
      "boundElements": [],
      "isDeleted": false
    },
    {
      "id": "files-text",
      "type": "text",
      "x": 75,
      "y": 1746,
      "width": 1270,
      "height": 40,
      "text": "Source files:  vector_store.py (schema, add, search)  |  embedder.py (batch pipeline, resume, retry)  |  provider.py (Gemini API calls)\n               search_code.py (hybrid search, RRF fusion)  |  config.py (LANCEDB_PATH, EMBEDDING_DIMS)  |  index.py (CLI entry point)",
      "fontSize": 11,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "strokeColor": "#868e96",
      "isDeleted": false,
      "opacity": 100,
      "angle": 0,
      "groupIds": [],
      "rawText": "Source files:  vector_store.py (schema, add, search)  |  embedder.py (batch pipeline, resume, retry)  |  provider.py (Gemini API calls)\n               search_code.py (hybrid search, RRF fusion)  |  config.py (LANCEDB_PATH, EMBEDDING_DIMS)  |  index.py (CLI entry point)"
    }
  ],
  "appState": {
    "viewBackgroundColor": "#ffffff",
    "gridSize": 20
  },
  "files": {}
}