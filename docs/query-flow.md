# Query Flow

How a user question becomes a researched answer. Covers the HTTP entry point, agent loop mechanics, tool dispatch, and what each tool reads from which store.

## Overview

```
POST /query { prompt }
    |
    v
  AgentLoop.run(prompt)
    |
    v
  Build system prompt (embeds full repo map from SQLite)
    |
    v
  Gemini tool-calling loop (up to 15 iterations)
    |   |
    |   |-- search_code  --> LanceDB (semantic) + Tantivy (lexical)
    |   |-- resolve_symbol --> SQLite (SCIP tables)
    |   |-- read_file     --> Filesystem (raw source)
    |   |-- read_map      --> SQLite (file_summaries)
    |   |
    v
  Synthesis phase (tools disabled, model writes answer)
    |
    v
  { answer, evidence[] }
```

## 1. HTTP Entry

`POST /query` in `src/indiseek/api/server.py`.

Request: `{ "prompt": "How does Vite HMR work?" }`

The handler lazy-initializes a singleton `AgentLoop` on first call. This opens all storage backends once (SQLite, LanceDB, Tantivy) and reuses them across requests. Then calls `agent.run(prompt)` and returns the `AgentResult` as JSON.

Response:
```json
{
  "answer": "...",
  "evidence": [
    { "step": "search_code(query='HMR CSS')", "detail": "10 results..." },
    { "step": "read_file(path='hmr.ts')",     "detail": "File: ..." }
  ]
}
```

## 2. Agent Initialization (once per process)

`create_agent_loop()` in `src/indiseek/agent/loop.py` opens three storage backends:

| Backend | Path | Condition | Purpose |
|---------|------|-----------|---------|
| SQLite | `data/indiseek.db` | Always | Symbols, chunks, SCIP cross-refs, file summaries |
| LanceDB | `data/lancedb/` | Dir exists + vectors > 0 + API key set | Semantic embedding search |
| Tantivy | `data/tantivy/` | Dir exists | BM25 lexical search |

A `CodeSearcher` wraps whichever combination of LanceDB/Tantivy is available. If only one backend exists, hybrid mode degrades to single-mode.

## 3. System Prompt Construction

Before the first LLM call, the agent builds a system prompt containing:

1. **Role** — "You are a codebase research agent."
2. **Repo map** — The full directory tree with one-line file summaries, generated by calling `read_map(store)` which queries the `file_summaries` table. This gives the model a table-of-contents of the entire indexed codebase.
3. **Tool documentation** — Usage instructions for each of the 4 tools.
4. **Strategy** — Search first, then resolve_symbol for navigation, then read_file for detail, then synthesize.
5. **Budget** — "You have 15 iterations. Use 8-10 for research, then synthesize."

The repo map is the key context-setting mechanism. The model sees every indexed file with its summary before making any tool calls, so it can reason about where to look.

## 4. Agent Loop

### Phases

| Iterations | Phase | Tools | Notes |
|------------|-------|-------|-------|
| 0-12 | Research | Enabled | Model calls tools freely |
| 13-14 | Synthesis | Disabled | Model forced to write answer |

### Per-Iteration Flow

```
1. Send conversation history to Gemini
2. If model returns text (no tool calls) --> done, return answer
3. For each tool call in the response:
   a. Execute the tool
   b. Truncate result to 15k chars if needed
   c. Append iteration budget warning if running low
   d. Inject resolve_symbol hint if iteration >= 5 and it hasn't been used
   e. Record as evidence step
4. Send all tool results back to Gemini as the next conversation turn
```

### Per-Run Caches

These are cleared at the start of each `run()` call:

- **File cache** — Dict mapping file paths to raw content. First `read_file` of a path reads from disk; subsequent reads of any range from the same file are served from memory.
- **Query cache** — Stores `(query, result)` pairs. Before executing a `search_code`, compares the new query against all cached queries using Jaccard similarity on token sets. If similarity >= 0.8, returns the cached result instead.
- **resolve_symbol flag** — Tracks whether the model has used `resolve_symbol` at all. If not used by iteration 5, a hint is injected into the next tool result.

### Budget Pressure Messages

Appended to every tool result:

| Remaining iterations | Message |
|---------------------|---------|
| > 5 | `[Iteration 3/15, 4 tool calls used]` |
| 2-5 | `[...start wrapping up research]` |
| 0-1 | `[...stop researching and synthesize your answer NOW]` |

At iteration 13, tools are disabled entirely and the model receives: "You have gathered enough evidence. Synthesize your answer now. No more tool calls are available."

## 5. Tool Details

### search_code

**Purpose:** Find relevant code chunks by content.

**Arguments:** `query` (required), `mode` (optional: hybrid/semantic/lexical, default hybrid)

**Pre-processing:**
1. Strip file path patterns from query (regex removes `path:`, `file:`, and path-like tokens)
2. Check query cache (Jaccard similarity >= 0.8 against past queries)

**Stores accessed:**

| Mode | Store | How |
|------|-------|-----|
| semantic | LanceDB | Embed query via Gemini API, cosine distance search over 768-dim vectors |
| lexical | Tantivy | BM25 full-text search over chunk content (en_stem tokenizer) |
| hybrid | Both | Fetch 2x limit from each, fuse with Reciprocal Rank Fusion (k=60) |

**RRF fusion:** For each result, score = `sum(1 / (60 + rank))` across whichever result lists it appears in. Results in both lists get `match_type="hybrid"`. Sorted by fused score descending.

**Returns:** Formatted text listing up to 10 results, each showing file path, symbol name, chunk type, match type, score, and a content preview (300 chars, 8 lines max).

**What it searches over:** The `chunks` table — AST-scoped code blocks. Each chunk is one top-level symbol (function, class, interface, type, enum, exported variable) or a module-level fallback for files with no extractable symbols. Chunks are produced by Tree-sitter parsing during indexing.

### resolve_symbol

**Purpose:** Navigate the code graph — definitions, references, callers, callees.

**Arguments:** `symbol_name` (required), `action` (required: definition/references/callers/callees)

**Store accessed:** SQLite only. Queries SCIP tables first, falls back to tree-sitter `symbols` table.

| Action | Primary query | Fallback |
|--------|--------------|----------|
| definition | `scip_occurrences` WHERE role='definition' AND symbol LIKE '%name%' | `symbols` WHERE name=? |
| references | `scip_occurrences` WHERE role='reference' AND symbol LIKE '%name%' | `symbols` WHERE name=? |
| callers | Get all references, then for each ref location find the enclosing symbol from `symbols` table by line range | None (requires SCIP) |
| callees | Find symbol's definition range, then query all SCIP references within that range | None (requires SCIP) |

**Returns:** Formatted text listing file:line locations. Example: `"Definition of 'createServer' (SCIP, 2 result(s)):\n  src/server/index.ts:45"`

### read_file

**Purpose:** Read raw source code from the indexed repository.

**Arguments:** `path` (required), `start_line` (optional), `end_line` (optional)

**Store accessed:** Filesystem at `REPO_PATH`. Path-validated to prevent directory traversal.

**Caching:** On first access, reads full file and caches in memory. Subsequent reads of any range from the same file are served from cache (formatted with the requested line range).

**Returns:** Source code with line numbers. Default shows first 200 lines with a truncation notice if longer.

```
File: packages/vite/src/node/server/hmr.ts (lines 1-200)
────────────────────────────────────────────────────────────
     1 | import fsp from 'node:fs/promises'
     2 | import path from 'node:path'
   ...
```

### read_map

**Purpose:** Browse the repository's directory tree with file summaries.

**Arguments:** `path` (optional subdirectory to scope to)

**Store accessed:** SQLite `file_summaries` table.

**Behavior:** Without a path, returns the full tree. With a path, returns only files under that directory.

**Returns:** ASCII tree with connectors. Each file shows its one-line summary.

```
packages/vite/src/node/
├── server/
│   ├── hmr.ts — Handles HMR update propagation and module invalidation
│   └── index.ts — Main dev server creation and configuration
└── plugins/
    └── css.ts — CSS plugin: transforms, HMR, and @import tracking
```

**Note:** The full tree is already embedded in the system prompt. This tool is mainly for re-reading a scoped subtree mid-conversation.

## 6. Storage Schema

### SQLite (`data/indiseek.db`)

**symbols** — Tree-sitter extracted declarations
- `id`, `file_path`, `name`, `kind` (function/class/interface/...), `start_line`, `end_line`, `signature`
- Indexed on: `name`, `file_path`, `kind`

**chunks** — AST-scoped code blocks (one per top-level symbol)
- `id`, `file_path`, `symbol_name`, `chunk_type` (symbol/module), `start_line`, `end_line`, `content`, `token_estimate`
- These are what gets embedded into LanceDB and indexed into Tantivy
- Indexed on: `file_path`

**scip_symbols** — SCIP symbol identifiers
- `id`, `symbol` (unique SCIP URI), `documentation`

**scip_occurrences** — Where each SCIP symbol is defined or referenced
- `id`, `symbol_id` (FK to scip_symbols), `file_path`, `start_line`, `role` (definition/reference)
- Indexed on: `symbol_id`, `file_path`

**file_summaries** — LLM-generated one-line file descriptions
- `id`, `file_path` (unique), `summary`, `language`, `line_count`

### LanceDB (`data/lancedb/`)

Single `chunks` table:
- `vector`: float32[768] — Gemini embedding
- `chunk_id`: FK to SQLite chunks.id
- `file_path`, `symbol_name`, `chunk_type`, `content`

Searched by cosine distance. Lower distance = more similar.

### Tantivy (`data/tantivy/`)

BM25 full-text index over chunk content:
- `content` field tokenized with `en_stem`
- `file_path`, `symbol_name`, `chunk_type` stored as raw (untokenized)
- `chunk_id` links back to SQLite

Searched by BM25 relevance. Higher score = more relevant.

## 7. What Gets Indexed vs. What Doesn't

The indexer (`scripts/index.py`) discovers files via `git ls-files` filtered to `.ts`/`.tsx` extensions. If `--filter` is passed, only files matching that path prefix are indexed.

This matters: if indexing was run with `--filter packages/vite/src/node`, then `packages/vite/src/client/client.ts` won't be in any store. `search_code` won't find it, `resolve_symbol` won't have SCIP data for it, and `read_map` won't show it. Only `read_file` can still access it (it reads from disk, not from the index) — but the agent would need to guess the path.
